---
title: Java架构的生命周期
date: 2019-11-05 20:38:01
tags: 
  - java
  - 架构
categories: java
---

 随着互联网的发展，网站应用的规模不断扩大，常规的垂直应用架构已无法应对，分布式服务架构以及流动计算架构势在必行，亟需一个治理系统确保架构有条不紊的演进。 

<!--more-->



## 简介

1. web1.0时代（1996年左右）

2. web2.0时代（2006年左右）

3. 互联网时代（2011年左右）

   ->互联网+ -> 智慧城市

   嘀嘀打车

   饿了么

4. 大数据 + 云计算

5. AI 未来以来时代



## 第一时期   单一应用架构

all in one.所有的模块和代码都在一起。技术也不分层。（2000年左右）也是网站初期的最早架构。也是互联网发展的最早十七。所有代码、业务都卸载JSP里面。

**问题**：

1. 代码不具备可维护性；
2. 容错性差；

> 因为所有的代码都卸载jsp页面中，当用户访问或某些原因发生异常
>
> 1. 用户会直接看到异常信息；
> 2. 有些情况下，该错误可能会导致服务宕机；

### 第一时期后阶段

**解决方案**：

1. 分成开发（提高维护性）

2. MVC架构是一个基于Java Web应用的设计模式；

3. 服务器分离部署

   

**特点：**

1. MVC分层开发，提高了维护性和解决容错性问题；
2. 数据库和项目分离部署；

**问题：**

随着用户的访问量持续增加，单台应用服务器无法满足需求。（高并发问题）

**解决方案：**

集群（集群方案解决）

**会出现的问题：**

1. 高并发
2. 高可用
3. 高性能

**如何提高系统并发能力：**

1. 垂直扩展（提升单机处理能力）;
2. 水平扩展（不断加服务器扩容）;

### 集群操作

集群：同一个业务，部署在多个服务器上。



**特点：**

项目采用集群（多台服务器部署）

**解决问题：**

1. 支持高并发；

2. 支持高可用；

**问题：**

1. （集群）用户的请求该往哪里进行转发？
2.  Session如何共享？Redis Cluster（Spring session + Redis）实现



**数据库压力变大**

通过nginx + tomcat集群方案，支持高并发（应用的性能提升访问），但是数据库的负载能力慢慢增加

**问题：**

怎么来提高数据库层面的访问压力？

**解决方案：**

读写分离



主从数据库之间进行数据同步。master主要负责增删改操作，slave负责读（查询）操作。

mysql本身就支持master-slave的功能（主从复制功能）

**使用搜索引擎缓解数据库的访问压力+能力**

数据库本身对大数据量查询效率慢，对模糊查询支持不是特别优秀。搜索是非常核心的功能（即使做了数据库读写分离），很多功能也不能有效解决（分词技术），针对该问题，有必要引入全文检索服务器功能。

**目前主流的搜索引擎技术：**

Solr  ElasticSearch



**引入缓存机制减轻数据库的访问压力**

随着访问量的持续增加，（数据库的访问压力持续增大，甚至无法满足需求）。虽然做了主从复制，对于热点数据，如果每次都从数据库中查询，数据库无法应付，导致无法对外提供服务。

最佳解决方案： Redis

1. 读写性能非常好；
2. 提供了丰富的数据类型；
3. 原子性；



**数据库的表进行水平和垂直拆分**

一张表里面又1千条数据，查询的性能很高

如查询有100万数据，查询的性能很慢

单个表性能做提升，能力终归还是有限的

**表为主：**

1. 垂直：一张表的字段总冷热字段拆分出两张表
2. 水平：按需求进行拆分。（省份、时间、）
3. 分库分表：采用第三方数据库中间件：mycat sharding-jdbc jrds(阿里)



**当前设计特点：**

通过设计保证高并发、高可用。（不断对服务器进行扩容）

当前很多公司用的是这种架构。



**问题：**

1. 服务器价钱增加。服务器忙闲不均问题，服务器的维护、人工成本、大量运维工程师
2. 可维护性很差
3. 可扩展性差（服务器）
4. 协同开发不方便（大家都去修改相同业务代码，易发生代码冲突/错误问题）
5. 单体架构（随着业务需求的不断增加，应用代码会变的越来越多），导致服务器部署时占用的磁盘空间变大。



## 第二时期 垂直应用架构

 当访问量逐渐增大，单一应用增加机器带来的加速度越来越小，将应用拆成互不相干的几个应用，以提升效率。此时，用于加速前端页面开发的Web框架(MVC)是关键。 

**水平拆分**

将一个打的应用拆分成多个小应用

一个原来的项目包含（controller/service/mapper/pojo...）

拆分成不同的小应用

```
parent   pom       # 父工程（放所有的pom.xml）
common.jar         # 公共库（相关工具类）
pojo.jar           # java bean
mapper.jar         # 数据持久层
service.jar        # 业务逻辑层
web.war            # web访问层
```

如何拆分，参考：[单体项目水平拆分](https://www.bilibili.com/video/av70669026/?p=9)

**解决问题：**

1. 模块复用；
2. 减少了服务器内容部署；



**垂直拆分**

按功能拆分

将一个大的应用按功能拆分成多个互不相干的小应用，每个应用都是独立的WEB应用程序

**解决问题：**

1. 维护性（如果发生需求变更，只需要调整某个应用模块即可）；
2. 功能扩展（随着业务的不断增加，只需要创建新的WEB程序即可）；
3. 协同开发方便（不同的团队修改不同的代码）；
4. 部署内容大小（性能扩展），如果哪台访问量大，只需要对该服务多部署几台即可；



此时，用于加速前端页面开发的web框架（MVC）是关键。



**问题：**

1. 客户对页面的要求会越来越高？（修改频繁）需要重新部署后台应用程序？（每个应用从头到尾都是完整的）。
2. 随着业务需求不断增加，需要很多个互不相干应用部署？这些应用之间一定会需要业务交互？



## 第三时期 分布式服务架构

 当垂直应用越来越多，应用之间交互不可避免，将核心业务抽取出来，作为独立的服务，逐渐形成稳定的服务中心，使前端应用能更快速的响应多变的市场需求。此时，用于提高业务复用及整合的分布式服务框架(RPC)是关键。 

**分布式服务架构**

分布式：将一个业务拆分成多个子业务，部署在不同的服务器上。

**解决方案：**

1. 客户对页面的要求会越来越高？（修改频繁）需要重新部署后台应用程序？（每个应用从头到尾都是完整的）。

   答：前后端分离



2. 随着业务需求不断增加，需要很多个互不相干应用部署？这些应用之间一定会需要业务交互？



**分析：**

以前如果都在一台服务器上（模块之间通过依赖jar完成调用）

现在都在不同的服务器上做的部署（分布式）。服务和服务之间通过进程间调用。

答：RPC/HTTP/HttpClient



**此时，架构的改变一定会带来一些新的技术和新的问题**

**问题：**

1. 分布式事务；
2. 分布式锁；
3. 分布式Session；
4. 分布式日志；

**问题：**

此时，用于提高业务服用和整合的分布式服务框架（RPC）是关键

1. 当服务越来越多，服务和服务之间的调用非常的混乱（我都不知道你有哪些服务）；
2. 当服务越来越多，容量的评估，小服务资源的浪费等问题逐渐显现；



## 第四时期 流动计算框架

 当服务越来越多，容量的评估，小服务资源的浪费等问题逐渐显现，此时需增加一个调度中心基于访问压力实时管理集群容量，提高集群利用率。此时，用于提高机器利用率的资源调度和治理中心(SOA)是关键。 

**SOA**

面向服务的架构（SOA）

**分布式服务治理（解决方案）中间件：Dubbo/SpringCloud**

基于访问压力实时管理集群容量，提高集群利用率。

Dubbo底层用的RPC协议。（Dubbo是一个RPC框架）

SpringCloud底层用的HTTP协议。





## 总结

**微服务：**

单体应用拆分成多个互不相干的小应用，每个小的应用称为微服务。

SOA(面向服务架构)  ->  微服务架构

**问题：**

1.  构建单体应用时，（SSM）即可。服务进行拆分（多个小应用）比如10个应用（大量重复的jar包，大量重复的配置文件）？

**解决方案：**

SpringBoot

SpringBoot目的：就是为了简化代码的开发和简化代码的框架构建。

**架构的改变一定会带来新的技术和新的问题**

**新技术：**

SpringBoot Dubbo SpringCloud

**新的问题和解决方案：**

1. 分布式事务——两段式提交；
2. 分布式锁——Redis SetNX功能，还有Zookeeper也能解决
3. 分布式Session——Redis 和Spring Session
4. 分布式日志——ELK



**优点：**

1. 微服务对服务的拆分变得更细（复用性强），提高开发效率；
2. 可根据需求使用最新的需求，比如SSH，SSM技术可以随意选择；
3. 适用于互联网项目，迭代周期短、开发效率快；

**缺点：**

1. 微服务过多的话、服务的管理（治理）成本高。
2. 不利于服务的部署，解决方案（Docker->K8s）
3. 技术难点在增加（分布式事务、锁、Session、日志）
4. 对程序员的技术要求变高（Dubbo SpringCloud SpringBoot Docker K8s）